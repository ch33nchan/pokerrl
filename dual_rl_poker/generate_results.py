#!/usr/bin/env python3
"""
Aggregate real experiment artifacts produced by the training script.

The utility scans ``results/`` for JSON files generated by
``run_real_training.py`` and writes an aggregate summary to
``results/experiment_summary.json``. The summary includes per-game statistics
and the full exploitability / NashConv curves for downstream analysis.
"""

from __future__ import annotations

import json
import statistics
from pathlib import Path
from typing import Dict, List, Sequence


RESULTS_DIR = Path("results")
SUMMARY_FILE = RESULTS_DIR / "experiment_summary.json"


def load_run(path: Path) -> Dict[str, object]:
    with path.open("r", encoding="utf-8") as fh:
        data = json.load(fh)

    history = data.get("training_history", [])
    if not history:
        raise ValueError(f"{path} does not contain any training history.")

    final = history[-1]
    if "iterations" not in data:
        raise ValueError("Missing iterations field; skipping legacy result")
    return {
        "path": str(path),
        "game": data["game"],
        "seed": int(data["seed"]),
        "iterations": int(data["iterations"]),
        "final_exploitability": float(final["exploitability"]),
        "final_nash_conv": float(final["nash_conv"]),
        "history": history,
        "policy_type": data.get("policy_type", "unknown"),
    }


def discover_runs(results_dir: Path) -> List[Path]:
    if not results_dir.exists():
        return []
    return sorted(results_dir.glob("*_seed*.json"))


def aggregate(runs: Sequence[Dict[str, object]]) -> Dict[str, Dict[str, float]]:
    grouped: Dict[str, List[Dict[str, object]]] = {}
    for run in runs:
        grouped.setdefault(run["game"], []).append(run)

    summary: Dict[str, Dict[str, float]] = {}
    for game, game_runs in grouped.items():
        exploitabilities = [float(run["final_exploitability"]) for run in game_runs]
        nash_convs = [float(run["final_nash_conv"]) for run in game_runs]
        summary[game] = {
            "num_runs": len(game_runs),
            "iterations": int(game_runs[0]["iterations"]),
            "mean_exploitability": statistics.fmean(exploitabilities),
            "stdev_exploitability": statistics.pstdev(exploitabilities) if len(exploitabilities) > 1 else 0.0,
            "mean_nash_conv": statistics.fmean(nash_convs),
            "stdev_nash_conv": statistics.pstdev(nash_convs) if len(nash_convs) > 1 else 0.0,
            "policy_types": {
                policy_type: sum(1 for run in game_runs if run.get("policy_type", "unknown") == policy_type)
                for policy_type in {run.get("policy_type", "unknown") for run in game_runs}
            },
        }
    return summary


def build_payload(runs: Sequence[Dict[str, object]]) -> Dict[str, object]:
    summary = aggregate(runs)
    payload = {
        "num_runs": len(runs),
        "games": summary,
        "runs": [
            {
                "path": run["path"],
                "game": run["game"],
                "seed": run["seed"],
                "iterations": run["iterations"],
                "final_exploitability": run["final_exploitability"],
                "final_nash_conv": run["final_nash_conv"],
                "exploitability_curve": [float(step["exploitability"]) for step in run["history"]],
                "nash_conv_curve": [float(step["nash_conv"]) for step in run["history"]],
                "policy_type": run.get("policy_type", "unknown"),
            }
            for run in runs
        ],
    }
    return payload


def main() -> None:
    paths = discover_runs(RESULTS_DIR)
    if not paths:
        print("No real experiment runs found under 'results/'. Nothing to summarise.")
        return

    runs = []
    for path in paths:
        try:
            runs.append(load_run(path))
        except ValueError:
            continue
    payload = build_payload(runs)

    SUMMARY_FILE.parent.mkdir(parents=True, exist_ok=True)
    with SUMMARY_FILE.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, indent=2)

    print(f"Wrote summary for {len(runs)} runs to {SUMMARY_FILE}")


if __name__ == "__main__":
    main()
